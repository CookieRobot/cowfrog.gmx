<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>frogGunF</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>frogNe</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//
randomize();

control = instance_find(controller,0);
if control == noone
{
control = instance_create(0,0,controller);
}
control.target = self;

s = instance_find(scoreTracker,0);
if s == noone
{
s = instance_create(0,0,scoreTracker);
}
if (global.town%4==1)
{
    i = irandom_range(0,1)
    switch(i)
    {
        case 0:
        setBGM(Angry_frog_from_the_east);
        break;
        case 1:
        setBGM(frog_in_f);
        break;
    }
}


draw_set_colour(c_black);
draw_set_halign(fa_center);
print("generating houses");
space = 1920;
safeHouse = 2;
while space &gt;150
{
safeHouse -=1;
if space &gt; 270 //any house can be made at this size
{
    var newHouse =  instance_create(1920-space,162,house)
    //choose size
    choice = irandom_range(5,5);
    newHouse.popCap = choice;
    switch(choice)
    {
        case 0:
            newHouse.sprite_index = size0House();
            
            
        break;
        case 1:
            newHouse.sprite_index =  size1House();
        break;
        case 2:
            newHouse.sprite_index =  size2House();
        break;
        case 3:
            newHouse.sprite_index =  size3House();
        break;
        case 4:
            newHouse.sprite_index =  size4House();
        break;
        case 5:
            newHouse.sprite_index =  size5House();
        break;
        case 6:
            newHouse.sprite_index =  size6House();
        break;
        case 7:
            newHouse.sprite_index =  size7House();
        break;
    }
    space = space- sprite_get_width(newHouse.sprite_index)
    newHouse.play = self;
    
    with(newHouse)
        {
            event_user(1);
            
        }
    
    if safeHouse&lt;0
    {
        with(newHouse)
        {
            
            event_user(0);
        }
    }
}
else 
{
    var newHouse = instance_create(1920-space,162,house);
    newHouse.sprite_index = size5House();
    space = space- sprite_get_width(newHouse.sprite_index)
    newHouse.play = self;
    newHouse.popCap = 5;
    with(newHouse)
        {
            event_user(1);
            
        }
    if safeHouse&lt;0
    {
        with(newHouse)
        {
            
            event_user(0);
        }
    }
    
    
}


}


/*
var newHouse instance_create(0,80,house);
newHouse.sprite_index = size0House();
newHouse.space = space- sprite_get_width(newHouse.sprite_index)
*/

jump = ord('Z');
swap = ord('A');
fire = ord('X');
left = vk_left;
up = vk_up;
down = vk_down;
right = vk_right;


yVelo=-4;
xVelo=5;
movingPlat = noone;
grounded = false;
facing=1;
jumpVelo = -7.5;
jumping = false;
maxXvelo =4;
bulletVelo = 24;
ded =0;
recentFire = 5;
maxClip = 6; 
clip = maxClip;
reloadTime = room_speed * 0.333; 
timeSinceFired = -1; 
waitBeforeReloadTime = room_speed * 0.666; 


//gravityIni = jumpVelo/-22.5
gravityVelo = .45;
startY = y;
//60 * .83 = 50
y-=1;// unstuck?!?!?! wtf

//animation settings
image_speed = .35;
texture_set_interpolation(false);

thatFuckingCollisonBug = false;// for finding that bug
//controls Initialize
jump = ord('Z');
swap = ord('A');
fire = ord('X');
left = vk_left;
up = vk_up;
down = vk_down;
right = vk_right;
pressSpaceChange =0;
pressSpace=0;
canInputPlay = true;//used for rejecting non-gameplay input

//used for checking frames for soundEffect
footStepTimer = 6;
alarm[0] =-1




//addFont
//font= font_add("PressStart2P-Regular.ttf", 8, 0, 0, 32, 128);
//draw_set_font(font);
//draw_set_halign(fa_right);

//input booleans
inputBooleans();
stun = true;
alarm[1] = room_speed


//used for checking single presses
lastFire = false;
lastJump = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// reload
clip++; 

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>stun = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>print("restarting room");
room_goto(gameOver);
draw_set_colour(c_white);
s.over = true;
control.target = s;
s.control = control; 
s.music = gameOverMusic(s.choice)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (stun)
{
pressLeft = false;
pressRight = false;
pressUp = false;
pressDown = false
pressJump = false;
pressFire = false;
//pressPause = false;
pressFireChange = false;
pressJumpChange = false;
pressLeftChange = false;
pressRightChange = false;
}

xMove = (-pressLeft + pressRight);

// caps playermovement but allows player to move faster if possible
if (!stun)
{
    if (grounded&amp;&amp;abs(xVelo)&lt;maxXvelo)
    {
    xVelo += xMove*.6*canInputPlay;
        if (abs(xVelo)&gt;maxXvelo)
        {
            xVelo = maxXvelo*sign(xVelo);
        }
    }
    if (!grounded&amp;&amp;abs(xVelo)&lt;maxXvelo)
    {
    xVelo += xMove*.6*canInputPlay;
        if (abs(xVelo)&gt;maxXvelo)
        {
            xVelo = (maxXvelo)*sign(xVelo);
        }
    }
    if(sign(xMove)!=sign(xVelo))// if player is moving in opposite direction they can move anyway
    {
    xVelo += xMove*.6*canInputPlay;
    }
}

grounded =  place_meeting(x,y+1,objSolid);




if(xMove!=0)
{
facing = xMove;
}
//controls
 

    if (grounded&amp;&amp;canInputPlay&amp;&amp;pressJumpChange)
    {
        pressJumpChange = false;
        yVelo = jumpVelo;
        audio_play_sound(playerJump,0,false);
        
    }
    
   
// Start reload if haven't fired recently OR have no bullets remaining
if ((timeSinceFired &gt;= waitBeforeReloadTime) &amp;&amp; alarm[2] == -1 &amp;&amp; clip &lt; maxClip) { //clip &lt;= 0 ||
    alarm[2] = reloadTime;
}
    
//fire bullet
if pressFireChange
{
    if (clip &gt; 0)
    {
        timeSinceFired = 0; 
        alarm[2] = -1; 
        
        recentFire = 0;
        var bullet = instance_create(x,y,playerShot);
        --clip;
        if (clip == 0)
        {
            audio_play_sound(gunShotGarb,0,false);
        }
        //print("shoot")
        if pressUp
        {
        bullet.x = x-5*facing
        bullet.direction = 90;
        bullet.image_angle = 90;
        if facing&lt;0
            {
                bullet.x-=1;
            }
        }
        else if pressDown &amp;&amp; !grounded
        {
        bullet.x = x+3*facing
        bullet.y = y+2
        bullet.direction = 270;
        bullet.image_angle = 270;
        if facing &lt;0
            {
            bullet.x +=2;
            
            }
        }
        else
        {
            bullet.y = y+3
            bullet.x = x-4*facing
            if facing &lt;0
            {
            bullet.y = y+4
            bullet.image_angle = 180;
            bullet.direction = 180;
            }
            
        }
       // part_particles_create(global.smokeSystem, bullet.x, bullet.y, global.smoke, 1);
    
    }
}
else 
{
    if (timeSinceFired &lt; waitBeforeReloadTime)
        timeSinceFired += 1; 
}





 

  

//gravity

if (!grounded)
{
    if (yVelo&lt;0 &amp;&amp;pressJump) 
    {
        yVelo+=gravityVelo;
        //print("lowgrav");
    }
    else
    {
        yVelo+=gravityVelo*1.4;
        //print("highgrav");
    }


}

//sets maxSpeed

if (abs(xVelo)&gt;maxXvelo&amp;&amp;grounded)
{   
        
        xVelo = facing*maxXvelo;
        
}

if (abs(xVelo)&gt;6&amp;&amp;!grounded)
{
        xVelo = facing*(maxXvelo+1);
}

if (yVelo&gt;7)
{
yVelo = 7;
}



//friction slowDown
if xMove==0&amp;&amp;abs(xVelo)!=0&amp;&amp;!stun //&amp;&amp; grounded)
{
    if ( abs(xVelo)-.325&lt;0  ) //prevents slowing down to opposite speed
    {
    xVelo = 0;
    }
    else
    {
    xVelo-=.325* sign(xVelo)*2;
    }


}









//add moving platforms velocity
xVeloFinal = xVelo;
yVeloFinal = yVelo;


if(place_meeting(x,y+yVelo,objSolid))
{



while(!place_meeting (x,y+sign(yVelo),objSolid))
{

y+=sign(yVelo);

}
yVelo = 0;
yVeloFinal = 0;
if(!grounded)
{
image_index =0; 
footStepCheck = false;
}
grounded=true;
}





//horizontal coll
holdXvelo = 0;
if(place_meeting(x+xVelo,y,objSolid))
{
//slope climbing calcs
i=0;
    if(place_meeting(x+xVelo,y,slope))
    {
        while (i&lt;9&amp;&amp;place_meeting(x+xVelo,y-i,objSolid))
        {
            i++
        }


        if (i&gt;=9) // if i got to equal the x value that means it wont be climbing the slope
        {
            //this part stops the player
            while(!place_meeting (x+sign(xVelo),y,objSolid))
            {
                x+=sign(xVelo);
            }
            
        xVelo = 0;
        xVeloFinal = 0;
         //show_debug_message("normal coll stop1A");
        }
        else 
        {
            y-=i // move y up to accommadate for the new slope position
        }
    }
    else if (place_meeting(x+2*facing,y,slope))
    {
        while (i&lt;abs(xVelo)+2&amp;&amp;place_meeting(x+xVelo,y-i,objSolid))
        {
            i++
        }


        if (i&gt;=abs(xVelo)+2) // if i got to equal the x value that means it wont be climbing the slope
        {
            //this part stops the player
            while(!place_meeting (x+sign(xVelo),y,objSolid))
            {
                x+=sign(xVelo);
            }
        xVelo = 0;
        xVeloFinal = 0;
        }
        else 
        {
            y-=i // move y up to accommadate for the new slope position
        }
    }
    else//normal collision detection
    {
    
    while(!place_meeting (x+sign(xVelo),y,objSolid))
        {

            x+=sign(xVelo);

        }
        xVelo = 0;
        xVeloFinal = 0;
         //show_debug_message("normal coll stop1B");
        //show_debug_message("normal coll stop");
    }
}
//end horizontal coll


//prevent getting stuck on corners

 //this will hold the xvelo to restore to prevent speed from stopping
if(place_meeting(x+xVelo,y+yVelo,objSolid))
{
 while(!place_meeting(x,y+sign(yVelo),objSolid))
 {
   x+=sign(xVelo);
   y+=sign(yVelo);
 }
yVelo=0;
holdXvelo = xVelo;
xVelo=0;
xVeloFinal = 0;
yVeloFinal = 0;


    if (!place_meeting(x+sign(xVelo),y,objSolid))
   {
    x+=sign(xVelo);
   }
   

grounded = true;
    //need to check horizontal cols again
    
    if(place_meeting(x+xVelo,y,objSolid))
    {
        //slope climbing calcs
        i=0;
    if(place_meeting(x+xVelo,y,slope))
    {
        while (i&lt;9&amp;&amp;place_meeting(x+xVelo,y-i,objSolid))
        {
            i++
        }


        if (i&gt;=9) // if i got to equal the x value that means it wont be climbing the slope
        {
            //this part stops the player
            while(!place_meeting (x+sign(xVelo),y,objSolid))
            {
                x+=sign(xVelo);
            }
        xVelo = 0;
        xVeloFinal = 0;
         //show_debug_message("normal coll stop2A");
        }
        else 
        {
            y-=i // move y up to accommadate for the new slope position
        }
    }
    else if (place_meeting(x+2*facing,y,slope))//if dashing
    {
        while (i&lt;abs(xVelo)+2&amp;&amp;place_meeting(x+xVelo,y-i,objSolid))
        {
            i++
        }


        if (i&gt;=abs(xVelo)+2) // if i got to equal the x value that means it wont be climbing the slope
        {
            //this part stops the player
            while(!place_meeting (x+sign(xVelo),y,objSolid))
            {
                x+=sign(xVelo);
            }
        xVelo = 0;
        xVeloFinal = 0;
        //show_debug_message("normal coll stop2B");
        }
        else 
        {
            y-=i // move y up to accommadate for the new slope position
        }
    }
    else//normal collision detection
    {
    while(!place_meeting (x+sign(xVelo),y,objSolid))
        {

            x+=sign(xVelo);

        }
        xVelo = 0;
        xVeloFinal = 0;
        
    }
}
        
}

// end getting stuck on corners


//checking downward for slopes

if(grounded)
{
    if(place_meeting(x+xVelo,y+yVelo+abs(xVelo)+2,objSolid))// checks for an available slope
    {
        
           while(!place_meeting(x+xVelo,y,objSolid))
            {
              
                y+=1;

            }
            y-=1;
    }
}


//sets new position
x+=xVeloFinal;
y+=yVeloFinal;
if(holdXvelo!=0)
{
xVelo=holdXvelo;
}


//final collision fix

if (place_meeting(x,y,objSolid))
{
    saved = false;
   // show_debug_message("Got stuck");
   for(m=0;m&lt;100;m++)
   {
        if(!place_meeting(x,y-m,objSolid))
            {
                y-=m;
                saved = true;   
            }
        if (saved)
            {
                 break;
            }  
   
        if(!place_meeting(x,y+m,objSolid))
            {
                y+=m;
                saved = true;   
            }
        if (saved)
            {
                 break;
            }  
  
        if(!place_meeting(x-m,y,objSolid))
            {
                x-=m;
                saved = true;   
            }
        if (saved)
            {
                 break;
            }  
   
        if(!place_meeting(x+m,y-m,objSolid))
            {
                x+=m;
                saved = true;   
            }
        if (saved)
            {
                 break;
            }  
   }
   if(!saved)
   {
        hpCurrent = 0;
        show_debug_message("Got stuck Unable to fix");
   }

}


if(grounded &amp;&amp; xMove!=0)
{
    if (alarm[0] ==-1)
    {
        //alarm[0] = footStepTimer;
    }
    
    
}
else
{
    //alarm[0]=-1;
}


//collision other check or something
if(place_meeting(x,y,objSolid))
{
//something i dunno
 violation=    instance_place(x,y,objSolid)
    x+= sign(violation.x)*-1;
    y-=sign(violation.y)*-1;
 
}

image_xscale= facing;
//grounded animations



if grounded
{
    if xVelo ==0
    {
        image_index = 0;
    }
    
    if pressUp
    {
        sprite_index = frogGunU;
    
    }
    else
    {
        sprite_index = frogGunF;
    }
    
}
else
{
    if yVelo &lt;0
    {
        image_index = 0;
    }
    else
    {
        image_index = 1;
    }

    if pressUp
    {
        sprite_index = frogGunUJ;
    
    }
    else if pressDown
    {
        sprite_index = frogGunD;
    }
    else
    {
        sprite_index = frogGunFJ;
    }
}

//camera controls
if x&gt;view_xview[0]+120 
{
    view_xview[0] = x-120;
}

//max camera range 
if view_xview[0]&gt; 1920-240
{
    view_xview[0]= 1920-240
}

//block going back
if x&lt; view_xview[0]
{
    x=view_xview[0];
}

if (ded!=0)
{
    sprite_index = frogNe;
    xVelo = ded
    if place_meeting(x,y+4,objSolid)
    {
    xVelo = 0
        if ded &lt;0 
        {
            image_angle = 90
        }
        else
        {
            image_angle = 270
        }
   
    }
    x+=xVelo
}

if pressPause
{
    print("pausing");
    //reset input
    inputBooleans();
    part_system_automatic_update(global.smokeSystem,false)
    part_system_automatic_update(global.bloodSystem,false)
    part_system_automatic_update(global.woodchipSystem,false)
    part_system_automatic_update(global.woodChunk1System,false)
    part_system_automatic_update(global.woodChunk2System,false)
    part_system_automatic_update(global.bloodBlueSystem,false)
    part_system_automatic_update(global.bloodBlueBigSystem,false)
    with(control)
    {
        x = view_xview[0]+8
        paused = true;
        pauseSurface = sprite_create_from_surface(application_surface,view_xport,view_yport,view_wport,view_hport,0,0,0,0);
        instance_deactivate_all(1);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="playerHurt">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//print("hurt")
var control = instance_find(controller,0);
if ded!=0
{
exit;
}
audio_play_sound(playerHit,0,false);
//music
setBGM(noone);
part_particles_create(global.bloodSystem, other.x, other.y, global.blood, 15);
if control == noone
{
exit;
}
if control.target = noone
{
exit;
}
control.target = noone;
if other.x&gt;x
{
image_angle = image_angle+45

ded = -2;
}
else
{
image_angle = image_angle-45 

ded = 2; 
}

yVelo = -8;


//stop all inputs 
//input booleans
pressLeft = false;
pressRight = false;
pressUp = false;
pressDown = false
pressJump = false;
pressFire = false;
pressFireChange = false;
pressJumpChange = false;
pressLeftChange = false;
pressRightChange = false;
s.choice = other.choice;
alarm[0] = room_speed *5;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

if(recentFire &lt;5)
{

drawX = x;
drawY = y
drawR = 0

    if pressUp
    {
    drawX = x-5*facing
        if facing&lt;0
        {
            drawX-=1;
        }
    drawY = y-10
    drawR=90;
    }
    else if pressDown &amp;&amp; !grounded
    {
    drawX = x+3*facing
    drawY = y+16
        if facing &lt;0
        {
        drawX +=1;
        
        }
    drawR= 270;
    }
    else
    {
        drawY = y+3
        drawX = x+12*facing
        if facing &lt;0
        {
        drawY = y+4
        drawR = 180;
        }
        
    }
if grounded 
{
 drawY -=floor(image_index);   
}
draw_sprite_ext(bulletFired,recentFire,drawX,drawY,1,1,drawR,c_white,1)
//animation speed
if recentFire&lt;2
{
    recentFire+=1
}
else
{
    recentFire+=.5
}

}

// Reload UI: draw over head
//draw_text(x + 32, y - 40, string(clip) + " / " + string(maxClip)); 
//draw_text(x + 32, y - 40 + 16, "W: " + string(timeSinceFired) + " / " + string(waitBeforeReloadTime)); 
//draw_text(x + 32, y - 40 + 32, "R: " + string(alarm[2]) + " / " + string(reloadTime)); 
var shellDrawRadius = 8; 
var shellDiffAngle = 360 / maxClip; 
for (var i = 0; i &lt; maxClip; i++) {
    var shellImg = 0; 
    if (i &lt; clip) {
        shellImg = 4; 
    }
    else if (i == clip) {
        if (alarm[2] &gt; reloadTime * 0.666) {
            shellImg = 1; 
        }
        else if (alarm[2] &gt; reloadTime * 0.333) { 
            shellImg = 2; 
        }
        else if (alarm[2] &gt; 0) { 
            shellImg = 3; 
        }
    }
    
    var shellAngle = 90 + (i * shellDiffAngle); 
    var shellX = x + lengthdir_x(shellDrawRadius, shellAngle);
    var shellY = y - 40 + lengthdir_y(shellDrawRadius, shellAngle);
    draw_sprite(spr_ui_reloadShell, shellImg, shellX, shellY); 
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
